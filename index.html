<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>매매 일지 분석 앱</title>
    <!-- PWA 관련 메타 태그 및 매니페스트 링크 -->
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png"> <!-- 나중에 실제 아이콘 경로로 변경 -->
    <meta name="theme-color" content="#6a994e"> <!-- 앱의 테마 색상 (상태 표시줄 등) -->

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Firebase SDK (v9 호환) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, deleteDoc, onSnapshot, query, updateDoc, arrayUnion, arrayRemove } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // 전역 변수 선언 (스코프 밖에서 접근 가능하도록)
        window.firebaseApp = null;
        window.db = null;
        window.auth = null;
        window.currentUserId = null;
        window.userTradesCollectionRef = null;
        window.setDoc = setDoc;
        window.deleteDoc = deleteDoc;
        window.doc = doc;
        window.collection = collection;
        window.query = query;
        window.onSnapshot = onSnapshot;
        window.updateDoc = updateDoc; // updateDoc 추가
        window.arrayUnion = arrayUnion; // arrayUnion 추가
        window.arrayRemove = arrayRemove; // arrayRemove 추가

        // 사용자 정의 태그를 위한 전역 변수
        window.customPsychologyTags = [];
        window.customEntryBasisTags = [];

        // 기본 심리 태그 및 진입 근거
        const predefinedPsychologyTags = [
            "사전에 준비된 자리", "사전에 준비되지 않은 자리", "조급함", "흥분상태",
            "복수매매", "냉철함", "우울함/무기력함", "피곤함", "비이성적",
            "복구 심리", "FOMO", "오기", "'이번만은' 심리", "욕심[5%이상의 고리스크]",
            "자신감", "성급한", "불안함", "리스크 계산함", "두려움", "추세", "역추세"
        ];
        const predefinedEntryBasisTags = [
            "피보나치 채널/비율", "일목균형표 (구름, 전환선 등)", "옵션", "금리선물 확인",
            "뉴스", "지표발표", "이평선", "미증시자리"
        ];


        // Google 인증 공급자 설정
        const googleProvider = new GoogleAuthProvider();
        window.signInWithGoogle = async function() {
            try {
                // signInWithPopup을 사용하여 팝업으로 로그인
                const result = await signInWithPopup(window.auth, googleProvider);
                // 로그인이 성공하면 onAuthStateChanged 리스너가 사용자 정보를 업데이트합니다.
                console.log("Google 로그인 성공:", result.user);
            } catch (error) {
                console.error("Google 로그인 실패:", error);
                const errorMessage = error.message;
                // 사용자에게 오류 메시지 표시
                document.getElementById('statusMessage').textContent = `Google 로그인 실패: ${errorMessage}`;
                document.getElementById('statusMessage').classList.remove('hidden');
                document.getElementById('statusMessage').classList.remove('text-green-600', 'bg-green-100', 'border-green-200');
                document.getElementById('statusMessage').classList.add('text-red-600', 'bg-red-100', 'border-red-200');
            }
        };

        window.signOutUser = async function() {
            try {
                await signOut(window.auth);
                console.log("로그아웃 성공");
                // 로그아웃 성공 시 상태 메시지 초기화 및 UI 업데이트 (onAuthStateChanged에 의해 처리됨)
                document.getElementById('statusMessage').textContent = '로그아웃되었습니다.';
                document.getElementById('statusMessage').classList.remove('hidden');
                document.getElementById('statusMessage').classList.remove('text-red-600', 'bg-red-100', 'border-red-200');
                document.getElementById('statusMessage').classList.add('text-green-600', 'bg-green-100', 'border-green-200');
            } catch (error) {
                console.error("로그아웃 실패:", error);
                document.getElementById('statusMessage').textContent = `로그아웃 실패: ${error.message}`;
                document.getElementById('statusMessage').classList.remove('hidden');
                document.getElementById('statusMessage').classList.remove('text-green-600', 'bg-green-100', 'border-red-200');
                document.getElementById('statusMessage').classList.add('text-red-600', 'bg-red-100', 'border-red-200');
            }
        };


        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Canvas 환경에서 제공되는 앱 ID
        // 사용자에게 제공받은 firebaseConfig를 직접 추가합니다.
        const firebaseConfig = {
          apiKey: "AIzaSyDtbBNTsYJGIJIrj-V9kqyXXOiHm5u43RM",
          authDomain: "future-futures-0u0.firebaseapp.com",
          projectId: "future-futures-0u0",
          storageBucket: "future-futures-0u0.firebasestorage.app",
          messagingSenderId: "591254718769",
          appId: "1:591254718769:web:45eccbfb9b6ed922fc4810",
          measurementId: "G-6RGPM8RZGG"
        };
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; // Canvas 환경에서 제공되는 초기 인증 토큰

        // Firebase 초기화 및 인증
        async function initializeFirebase() {
            if (!firebaseConfig || !firebaseConfig.projectId) {
                console.error("Firebase 초기화 실패: 'projectId'가 Firebase 설정에 제공되지 않았습니다. 환경 변수 '__firebase_config'를 확인해주세요.");
                document.getElementById('statusMessage').textContent = 'Firebase 초기화 오류: 프로젝트 ID가 누락되었습니다. 환경 설정을 확인해주세요.';
                document.getElementById('statusMessage').classList.remove('hidden');
                document.getElementById('loadingSpinner').classList.add('hidden');
                document.getElementById('statusMessage').classList.remove('text-green-600', 'bg-green-100', 'border-green-200');
                document.getElementById('statusMessage').classList.add('text-red-600', 'bg-red-100', 'border-red-200');
                return; // 초기화 중단
            }

            try {
                window.firebaseApp = initializeApp(firebaseConfig);
                window.db = getFirestore(window.firebaseApp);
                window.auth = getAuth(window.firebaseApp);

                onAuthStateChanged(window.auth, async (user) => {
                    if (user) {
                        window.currentUserId = user.uid;
                        let userIdentifier = `ID: ${user.uid}`; // 전체 UID 표시
                        if (user.isAnonymous) {
                            userIdentifier += ' - 익명';
                        } else if (user.email) {
                            userIdentifier += ` (${user.email}) - Google`;
                        }
                        document.getElementById('userIdDisplay').textContent = `사용자: ${userIdentifier}`;
                        
                        // 로그인 상태에 따라 로그인/로그아웃 버튼 표시 토글
                        document.getElementById('googleSignInBtn').classList.add('hidden');
                        document.getElementById('signOutBtn').classList.remove('hidden');

                        // 사용자 전용 컬렉션 경로 설정
                        window.userTradesCollectionRef = window.collection(window.db, `artifacts/${appId}/users/${window.currentUserId}/trades`);
                        // 사용자 정의 태그 컬렉션 경로 설정
                        window.userCustomTagsDocRef = window.doc(window.db, `artifacts/${appId}/users/${window.currentUserId}/settings/custom_tags`);
                        
                        setupRealtimeListener();
                        loadCustomTags(); // 사용자 정의 태그 로드
                    } else {
                        console.log("사용자 로그인되지 않음. 로그인 버튼 표시 및 익명 로그인 시도.");
                        // 사용자가 로그인되지 않은 경우 UI 업데이트
                        document.getElementById('userIdDisplay').textContent = '사용자: 로그인 필요';
                        document.getElementById('googleSignInBtn').classList.remove('hidden'); // 항상 보이도록
                        document.getElementById('signOutBtn').classList.add('hidden');

                        // 이전 사용자 데이터 클리어 (로그아웃 시 데이터 초기화)
                        window.trades = [];
                        window.customPsychologyTags = []; // 로그아웃 시 태그도 초기화
                        window.customEntryBasisTags = []; // 로그아웃 시 태그도 초기화
                        renderTradeHistory();
                        updateDashboard();
                        updateReports();
                        renderTagCheckboxes(); // 체크박스 초기화
                        renderTagManagementSections(); // 태그 관리 섹션 초기화

                        try {
                            // 익명 로그인 시도 (이것이 사용자에게 초기 UID를 제공하여 Firestore 사용 가능하게 함)
                            // signInAnonymously는 이미 로그인된 익명 사용자가 있으면 새로운 토큰을 주지 않고
                            // 기존 토큰을 반환하므로 안전합니다.
                            await signInAnonymously(window.auth);
                            console.log("익명 로그인 성공 또는 기존 익명 세션 재활용.");
                        } catch (error) {
                            console.error("익명 로그인 시도 실패:", error);
                            document.getElementById('statusMessage').textContent = '데이터 로드 실패: 익명 로그인에 실패했습니다. 네트워크 또는 Firebase 설정을 확인해주세요.';
                            document.getElementById('statusMessage').classList.remove('hidden');
                            document.getElementById('statusMessage').classList.remove('text-green-600', 'bg-green-100', 'border-green-200');
                            document.getElementById('statusMessage').classList.add('text-red-600', 'bg-red-100', 'border-red-200');
                            document.getElementById('loadingSpinner').classList.add('hidden');
                        }
                    }
                });
            } catch (error) {
                console.error("Firebase 초기화 오류:", error);
                document.getElementById('statusMessage').textContent = 'Firebase 초기화 오류: ' + error.message;
                document.getElementById('statusMessage').classList.remove('hidden');
            }
        }

        // 실시간 데이터 리스너 설정
        function setupRealtimeListener() {
            if (!window.userTradesCollectionRef) {
                console.warn("userTradesCollectionRef가 아직 설정되지 않았습니다.");
                document.getElementById('statusMessage').textContent = '데이터를 불러올 수 없습니다: 사용자 컬렉션 경로가 설정되지 않았습니다.';
                document.getElementById('statusMessage').classList.remove('hidden');
                document.getElementById('statusMessage').classList.remove('text-green-600', 'bg-green-100', 'border-green-200');
                document.getElementById('statusMessage').classList.add('text-red-600', 'bg-red-100', 'border-red-200');
                return;
            }

            const q = window.query(window.userTradesCollectionRef);
            window.onSnapshot(q, (snapshot) => {
                const fetchedTrades = [];
                snapshot.forEach((doc) => {
                    fetchedTrades.push({ id: doc.id, ...doc.data() });
                });
                window.trades = fetchedTrades; // 전역 trades 변수 업데이트
                renderTradeHistory();
                updateDashboard();
                updateReports(); // 보고서 업데이트 추가
                document.getElementById('loadingSpinner').classList.add('hidden');
                document.getElementById('statusMessage').classList.add('hidden');
            }, (error) => {
                console.error("Firebase 데이터 실시간 동기화 오류:", error);
                document.getElementById('statusMessage').textContent = '데이터 동기화 오류: ' + error.message;
                document.getElementById('statusMessage').classList.remove('hidden');
                document.getElementById('loadingSpinner').classList.add('hidden');
            });
        }

        // 사용자 정의 태그 로드
        async function loadCustomTags() {
            if (!window.userCustomTagsDocRef) {
                console.warn("userCustomTagsDocRef가 아직 설정되지 않았습니다.");
                return;
            }
            window.onSnapshot(window.userCustomTagsDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    window.customPsychologyTags = data.psychologyTags || [];
                    window.customEntryBasisTags = data.entryBasisTags || [];
                } else {
                    window.customPsychologyTags = [];
                    window.customEntryBasisTags = [];
                }
                renderTagCheckboxes();
                renderTagManagementSections();
            }, (error) => {
                console.error("사용자 정의 태그 로드 실패:", error);
                document.getElementById('statusMessage').textContent = '사용자 정의 태그 로드 실패: ' + error.message;
                document.getElementById('statusMessage').classList.remove('hidden');
            });
        }

        // 사용자 정의 태그 저장
        async function saveCustomTags() {
            if (!window.userCustomTagsDocRef || !window.currentUserId) {
                document.getElementById('statusMessage').textContent = '태그 저장 실패: 로그인 상태를 확인해주세요.';
                document.getElementById('statusMessage').classList.remove('hidden');
                return;
            }
            try {
                await window.setDoc(window.userCustomTagsDocRef, {
                    psychologyTags: window.customPsychologyTags,
                    entryBasisTags: window.customEntryBasisTags
                }, { merge: true }); // 기존 필드는 유지하면서 병합
                document.getElementById('statusMessage').textContent = '태그가 성공적으로 저장되었습니다!';
                document.getElementById('statusMessage').classList.remove('hidden');
                document.getElementById('statusMessage').classList.remove('text-red-600', 'bg-red-100', 'border-red-200');
                document.getElementById('statusMessage').classList.add('text-green-600', 'bg-green-100', 'border-green-200');
            } catch (error) {
                console.error("태그 저장 실패:", error);
                document.getElementById('statusMessage').textContent = '태그 저장 실패: ' + error.message;
                document.getElementById('statusMessage').classList.remove('hidden');
                document.getElementById('statusMessage').classList.remove('text-green-600', 'bg-green-100', 'border-green-200');
                document.getElementById('statusMessage').classList.add('text-red-600', 'bg-red-100', 'border-red-200');
            }
            setTimeout(() => { document.getElementById('statusMessage').classList.add('hidden'); }, 3000);
        }

        // 태그 추가
        window.addCustomTag = async function(type) {
            const inputId = type === 'psychology' ? 'newPsychologyTag' : 'newEntryBasisTag';
            const newTag = document.getElementById(inputId).value.trim();
            if (newTag && (type === 'psychology' && !predefinedPsychologyTags.includes(newTag) && !window.customPsychologyTags.includes(newTag) ||
                          type === 'entryBasis' && !predefinedEntryBasisTags.includes(newTag) && !window.customEntryBasisTags.includes(newTag))) {
                if (type === 'psychology') {
                    window.customPsychologyTags.push(newTag);
                } else {
                    window.customEntryBasisTags.push(newTag);
                }
                document.getElementById(inputId).value = '';
                await saveCustomTags();
                renderTagCheckboxes();
                renderTagManagementSections();
            } else if (newTag) {
                 document.getElementById('statusMessage').textContent = '이미 존재하거나 유효하지 않은 태그입니다.';
                 document.getElementById('statusMessage').classList.remove('hidden', 'text-green-600', 'bg-green-100', 'border-green-200');
                 document.getElementById('statusMessage').classList.add('text-red-600', 'bg-red-100', 'border-red-200');
                 setTimeout(() => { document.getElementById('statusMessage').classList.add('hidden'); }, 3000);
            }
        };

        // 태그 삭제
        window.deleteCustomTag = async function(type, tag) {
            if (confirm(`'${tag}' 태그를 삭제하시겠습니까?`)) {
                if (type === 'psychology') {
                    window.customPsychologyTags = window.customPsychologyTags.filter(t => t !== tag);
                } else {
                    window.customEntryBasisTags = window.customEntryBasisTags.filter(t => t !== tag);
                }
                await saveCustomTags();
                renderTagCheckboxes();
                renderTagManagementSections();
            }
        };

        // 매매 기록 폼에 태그 체크박스 동적 렌더링
        function renderTagCheckboxes() {
            const psychologyContainer = document.getElementById('psychologyCheckboxes');
            const entryBasisContainer = document.getElementById('entryBasisCheckboxes');

            psychologyContainer.innerHTML = '';
            entryBasisContainer.innerHTML = '';

            // 2-1 상태 기반 심리
            const stateBasedPsyHeader = document.createElement('h4');
            stateBasedPsyHeader.className = "font-medium text-gray-700 mb-2";
            stateBasedPsyHeader.textContent = "2-1 상태 기반 심리 [현재의 내 심리는?]";
            psychologyContainer.appendChild(stateBasedPsyHeader);

            const stateBasedPsychology = [
                "사전에 준비된 자리", "사전에 준비되지 않은 자리", "조급함", "흥분상태",
                "복수매매", "냉철함", "우울함/무기력함", "피곤함", "비이성적"
            ];
            stateBasedPsychology.forEach(tag => {
                const label = document.createElement('label');
                label.className = "block";
                label.innerHTML = `<input type="checkbox" name="psychology" value="${tag}" class="mr-2">${tag}`;
                psychologyContainer.appendChild(label);
            });

            // 2-2 일반 심리
            const generalPsyHeader = document.createElement('h4');
            generalPsyHeader.className = "font-medium text-gray-700 mb-2 mt-4";
            generalPsyHeader.textContent = "2-2 일반 심리";
            psychologyContainer.appendChild(generalPsyHeader);

            const generalPsychology = [
                "복구 심리", "FOMO", "오기", "'이번만은' 심리", "욕심[5%이상의 고리스크]",
                "자신감", "성급한", "불안함", "리스크 계산함", "두려움", "추세", "역추세"
            ];
            generalPsychology.forEach(tag => {
                const label = document.createElement('label');
                label.className = "block";
                label.innerHTML = `<input type="checkbox" name="psychology" value="${tag}" class="mr-2">${tag}`;
                psychologyContainer.appendChild(label);
            });

            // 사용자 정의 심리 태그 (Dynamic)
            if (window.customPsychologyTags.length > 0) {
                const customPsyHeader = document.createElement('h4');
                customPsyHeader.className = "font-medium text-gray-700 mb-2 mt-4";
                customPsyHeader.textContent = "2-3 사용자 정의 심리 태그";
                psychologyContainer.appendChild(customPsyHeader);
                window.customPsychologyTags.forEach(tag => {
                    const label = document.createElement('label');
                    label.className = "block";
                    label.innerHTML = `<input type="checkbox" name="psychology" value="${tag}" class="mr-2">${tag}`;
                    psychologyContainer.appendChild(label);
                });
            }


            // 3-1 신호 기반
            const signalBasedEntryHeader = document.createElement('h4');
            signalBasedEntryHeader.className = "font-medium text-gray-700 mb-2 col-span-full";
            signalBasedEntryHeader.textContent = "3-1 신호 기반";
            entryBasisContainer.appendChild(signalBasedEntryHeader);

            predefinedEntryBasisTags.forEach(tag => {
                const label = document.createElement('label');
                label.className = "block";
                label.innerHTML = `<input type="checkbox" name="entryBasis" value="${tag}" class="mr-2">${tag}`;
                entryBasisContainer.appendChild(label);
            });

            // 사용자 정의 진입 근거 태그 (Dynamic)
            if (window.customEntryBasisTags.length > 0) {
                const customEntryHeader = document.createElement('h4');
                customEntryHeader.className = "font-medium text-gray-700 mb-2 mt-4 col-span-full";
                customEntryHeader.textContent = "3-2 사용자 정의 진입 근거 태그";
                entryBasisContainer.appendChild(customEntryHeader);
                window.customEntryBasisTags.forEach(tag => {
                    const label = document.createElement('label');
                    label.className = "block";
                    label.innerHTML = `<input type="checkbox" name="entryBasis" value="${tag}" class="mr-2">${tag}`;
                    entryBasisContainer.appendChild(label);
                });
            }
        }

        // 태그 관리 섹션 렌더링
        function renderTagManagementSections() {
            const psychologyTagsDisplay = document.getElementById('psychologyTagsDisplay');
            const entryBasisTagsDisplay = document.getElementById('entryBasisTagsDisplay');

            psychologyTagsDisplay.innerHTML = '';
            entryBasisTagsDisplay.innerHTML = '';

            window.customPsychologyTags.forEach(tag => {
                const span = document.createElement('span');
                span.className = "inline-flex items-center bg-blue-100 text-blue-800 text-xs font-medium px-2.5 py-0.5 rounded-full mr-2 mb-2 dark:bg-blue-900 dark:text-blue-200";
                span.innerHTML = `${tag} <button onclick="deleteCustomTag('psychology', '${tag}')" class="ml-1 text-blue-600 hover:text-blue-900 dark:text-blue-300 dark:hover:text-blue-500 font-bold leading-none">&times;</button>`;
                psychologyTagsDisplay.appendChild(span);
            });

            window.customEntryBasisTags.forEach(tag => {
                const span = document.createElement('span');
                span.className = "inline-flex items-center bg-green-100 text-green-800 text-xs font-medium px-2.5 py-0.5 rounded-full mr-2 mb-2 dark:bg-green-900 dark:text-green-200";
                span.innerHTML = `${tag} <button onclick="deleteCustomTag('entryBasis', '${tag}')" class="ml-1 text-green-600 hover:text-green-900 dark:text-green-300 dark:hover:text-green-500 font-bold leading-none">&times;</button>`;
                entryBasisTagsDisplay.appendChild(span);
            });
        }


        // Dark Mode Toggle Logic
        window.toggleDarkMode = function() {
            document.documentElement.classList.toggle('dark-mode');
            const isDarkMode = document.documentElement.classList.contains('dark-mode');
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            updateChartColors(isDarkMode); // 차트 색상 업데이트
        };

        // 차트 색상 업데이트 함수 (다크 모드 전환 시 호출)
        function updateChartColors(isDarkMode) {
            const textColor = isDarkMode ? '#e2e8f0' : '#333'; // lightgray-200 : gray-800
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';

            // 공통 옵션 업데이트
            const commonScalesOptions = {
                y: {
                    beginAtZero: true,
                    max: 100,
                    ticks: {
                        color: textColor, // Y축 텍스트 색상
                        callback: function(value) {
                            return value + '%';
                        }
                    },
                    grid: {
                        color: gridColor // Y축 그리드 색상
                    }
                },
                x: {
                    ticks: {
                        color: textColor, // X축 텍스트 색상
                        callback: function(value, index, values) {
                            return wrapLabel(this.getLabelForValue(value), 16);
                        },
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 0
                    },
                    grid: {
                        color: gridColor // X축 그리드 색상
                    }
                }
            };
            
            // Result Breakdown Chart (Doughnut)
            if (resultBreakdownChart && resultBreakdownChart.options && resultBreakdownChart.options.plugins && resultBreakdownChart.options.plugins.legend && resultBreakdownChart.options.plugins.legend.labels) {
                resultBreakdownChart.options.plugins.legend.labels.color = textColor;
            }

            // Bar Charts
            if (psychologyImpactChart) {
                psychologyImpactChart.options.scales = JSON.parse(JSON.stringify(commonScalesOptions)); // 깊은 복사
            }
            if (entryBasisEffectivenessChart) {
                entryBasisEffectivenessChart.options.scales = JSON.parse(JSON.stringify(commonScalesOptions)); // 깊은 복사
            }
            

            // Factor Analysis Chart (Horizontal Bar)
            if (factorAnalysisChart) {
                factorAnalysisChart.options.scales = {
                    x: {
                        beginAtZero: true,
                        ticks: {
                            precision: 0,
                            color: textColor // X축 텍스트 색상
                        },
                        grid: {
                            color: gridColor // X축 그리드 색상
                        }
                    },
                    y: {
                        ticks: {
                            color: textColor, // Y축 텍스트 색상
                            callback: function(value, index, values) {
                                return wrapLabel(this.getLabelForValue(value), 25);
                            },
                            autoSkip: false,
                            maxRotation: 0,
                            minRotation: 0
                        },
                        grid: {
                            color: gridColor // Y축 그리드 색상
                        }
                    }
                };
            }


            // 차트 툴팁 텍스트 색상 업데이트 (Chart.js 기본값이 다크모드에 맞춰 자동으로 변경되지 않을 경우 수동 설정)
            const tooltipFontColor = isDarkMode ? '#1a202c' : '#ffffff'; // 배경에 따라 텍스트 색상 반전
            const tooltipBgColor = isDarkMode ? '#e2e8f0' : 'rgba(0, 0, 0, 0.8)'; // 배경에 따라 툴팁 배경색 반전

            [resultBreakdownChart, psychologyImpactChart, entryBasisEffectivenessChart, factorAnalysisChart].forEach(chart => {
                if (chart && chart.options && chart.options.plugins && chart.options.plugins.tooltip) {
                    chart.options.plugins.tooltip.titleColor = tooltipFontColor;
                    chart.options.plugins.tooltip.bodyColor = tooltipFontColor;
                    chart.options.plugins.tooltip.backgroundColor = tooltipBgColor;
                    // 툴팁 보더 색상 (선택 사항)
                    chart.options.plugins.tooltip.borderColor = isDarkMode ? '#6a994e' : '#5a8542';
                    chart.options.plugins.tooltip.borderWidth = 1;
                }
            });

            // 모든 차트 업데이트
            if (resultBreakdownChart) resultBreakdownChart.update();
            if (psychologyImpactChart) psychologyImpactChart.update();
            if (entryBasisEffectivenessChart) entryBasisEffectivenessChart.update();
            if (factorAnalysisChart) factorAnalysisChart.update();
        }


        // Window onload에서 Firebase 초기화 호출
        window.onload = function() {
            // 저장된 테마 설정 로드
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                document.documentElement.classList.add('dark-mode');
            }
            
            // HTML 요소들을 찾기 위한 변수들을 스크립트 상단으로 이동하거나, 직접 접근하도록 변경
            // 모달 닫기 버튼 이벤트
            const confirmModalCloseBtn = document.getElementById('confirmModalClose');
            if (confirmModalCloseBtn) { // 요소가 존재하는지 확인
                confirmModalCloseBtn.addEventListener('click', hideConfirmModal);
            }
            const cancelDeleteBtn = document.getElementById('cancelDelete');
            if (cancelDeleteBtn) { // 요소가 존재하는지 확인
                cancelDeleteBtn.addEventListener('click', hideConfirmModal);
            }


            document.getElementById('date').value = new Date().toISOString().split('T')[0]; // Set default entry date to today
            initializeCharts(); // 차트 초기화는 색상 업데이트보다 먼저!
            updateChartColors(savedTheme === 'dark'); // 다크 모드 초기화 후 차트 색상 업데이트
            updateResultFieldRequirements(); // Set initial required status
            initializeFirebase(); // Firebase 초기화
            
            // Service Worker 등록
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => {
                        console.log('Service Worker 등록 성공:', registration);
                    })
                    .catch(error => {
                        console.error('Service Worker 등록 실패:', error);
                    });
            }
        };


        const tradeForm = document.getElementById('tradeForm');
        const tradeHistoryBody = document.getElementById('tradeHistoryBody');
        window.trades = []; // Firebase에서 관리되므로 초기화 시 빈 배열로 시작합니다.

        // Chart instances, will be initialized in initializeCharts()
        let resultBreakdownChart;
        let psychologyImpactChart;
        let entryBasisEffectivenessChart;
        let factorAnalysisChart;

        const resultOutcomeSelect = document.getElementById('resultOutcome');
        const rRatioInput = document.getElementById('rRatio');
        const exitReasonSelect = document.getElementById('exitReason');
        const replayQuestion1Select = document.getElementById('replayQuestion1');
        const replayQuestion2Textarea = document.getElementById('replayQuestion2');
        const replayQuestion3Input = document.getElementById('replayQuestion3');
        const exitDateInput = document.getElementById('exitDate');

        let currentEditingTradeId = null; // 수정 중인 매매 ID 추적

        // 모달 관련 요소
        const confirmModalOverlay = document.getElementById('confirmModalOverlay');
        const confirmDeleteButton = document.getElementById('confirmDelete');
        let tradeIdToDelete = null;

        // Utility function to wrap long labels
        function wrapLabel(label, maxCharsPerLine) {
            if (typeof label !== 'string') return label;
            if (label.length <= maxCharsPerLine) return label;
            const words = label.split(' ');
            let lines = [];
            let currentLine = '';
            words.forEach(word => {
                if ((currentLine + word).length > maxCharsPerLine && currentLine.length > 0) {
                    lines.push(currentLine.trim());
                    currentLine = word + ' ';
                } else {
                    currentLine += word + ' ';
                }
            });
            lines.push(currentLine.trim());
            return lines;
        }

        // Initialize Charts (This function needs to be defined BEFORE it's called in window.onload)
        // Moved the definition here for clarity and correct order.
        // The previous copy of this function at the bottom was redundant and could be removed.
        // For the purpose of this fix, I'll keep the single definition and ensure it's properly placed.
        // (No, let's remove the redundant one and keep the clean one.)
        // This function block has been moved up in the previous response and should be correct.
        // No changes needed here, just re-iterating its importance for order.


        // Update Charts and Summary
        function updateDashboard() {
            if (!window.trades) {
                console.warn("Trades data is not available yet.");
                return;
            }
            const completedTrades = window.trades.filter(t => t.resultOutcome !== '진행 중');

            // Overall Performance
            const totalTrades = completedTrades.length;
            document.getElementById('totalTrades').textContent = totalTrades;

            const winTrades = completedTrades.filter(t => t.resultOutcome === '수익').length;
            const winRate = totalTrades > 0 ? (winTrades / totalTrades * 100).toFixed(2) : 0;
            document.getElementById('winRate').textContent = `${winRate}%`;

            const totalRR = completedTrades.reduce((sum, t) => sum + (parseFloat(t.rRatio) || 0), 0);
            const avgRR = totalTrades > 0 ? (totalRR / totalTrades).toFixed(2) : 0;
            document.getElementById('avgRR').textContent = avgRR;

            // Result Breakdown Chart
            const resultCounts = { '수익': 0, '손절': 0, '본절': 0, '진행 중': 0 };
            window.trades.forEach(trade => {
                if (resultCounts[trade.resultOutcome] !== undefined) {
                    resultCounts[trade.resultOutcome]++;
                }
            });
            if (resultBreakdownChart) { // Ensure chart exists before updating
                resultBreakdownChart.data.datasets[0].data = [resultCounts['수익'], resultCounts['손절'], resultCounts['본절'], resultCounts['진행 중']];
                resultBreakdownChart.update();
            }


            // Psychology Impact Chart (only for completed trades)
            const psychologyWinRates = {};
            const allPsychologyTags = new Set([...predefinedPsychologyTags, ...window.customPsychologyTags]); // 미리 정의된 태그와 사용자 정의 태그 결합

            completedTrades.forEach(trade => {
                const psychologyTags = Array.isArray(trade.psychology) ? trade.psychology : [];
                psychologyTags.forEach(tag => {
                    if (!psychologyWinRates[tag]) {
                        psychologyWinRates[tag] = { wins: 0, total: 0 };
                    }
                    psychologyWinRates[tag].total++;
                    if (trade.resultOutcome === '수익') {
                        psychologyWinRates[tag].wins++;
                    }
                });
            });

            const psychologyLabels = Array.from(allPsychologyTags).sort();
            const psychologyData = psychologyLabels.map(tag => {
                if (psychologyWinRates[tag] && psychologyWinRates[tag].total > 0) {
                    return (psychologyWinRates[tag].wins / psychologyWinRates[tag].total * 100).toFixed(2);
                }
                return 0; // 데이터가 없는 태그는 0%
            });

            if (psychologyImpactChart) { // Ensure chart exists before updating
                psychologyImpactChart.data.labels = psychologyLabels;
                psychologyImpactChart.data.datasets[0].data = psychologyData;
                psychologyImpactChart.update();
            }


            // Entry Basis Effectiveness Chart (only for completed trades)
            const entryBasisWinRates = {};
            const allEntryBasisTags = new Set([...predefinedEntryBasisTags, ...window.customEntryBasisTags]); // 미리 정의된 태그와 사용자 정의 태그 결합

            completedTrades.forEach(trade => {
                const entryBasisTags = Array.isArray(trade.entryBasis) ? trade.entryBasis : [];
                entryBasisTags.forEach(tag => {
                    if (!entryBasisWinRates[tag]) {
                        entryBasisWinRates[tag] = { wins: 0, total: 0 };
                    }
                    entryBasisWinRates[tag].total++;
                    if (trade.resultOutcome === '수익') {
                        entryBasisWinRates[tag].wins++;
                    }
                });
            });

            const entryBasisLabels = Array.from(allEntryBasisTags).sort();
            const entryBasisData = entryBasisLabels.map(tag => {
                if (entryBasisWinRates[tag] && entryBasisWinRates[tag].total > 0) {
                    return (entryBasisWinRates[tag].wins / entryBasisWinRates[tag].total * 100).toFixed(2);
                }
                return 0; // 데이터가 없는 태그는 0%
            });

            if (entryBasisEffectivenessChart) { // Ensure chart exists before updating
                entryBasisEffectivenessChart.data.labels = entryBasisLabels;
                entryBasisEffectivenessChart.data.datasets[0].data = entryBasisData;
                entryBasisEffectivenessChart.update();
            }


            // Success/Failure Factor Analysis Chart (only for completed trades)
            const factorCounts = {};
            completedTrades.forEach(trade => {
                const factors = Array.isArray(trade.factors) ? trade.factors : [];
                factors.forEach(factor => {
                    factorCounts[factor] = (factorCounts[factor] || 0) + 1;
                });
            });

            const sortedFactors = Object.entries(factorCounts).sort(([, a], [, b]) => b - a);
            if (factorAnalysisChart) { // Ensure chart exists before updating
                factorAnalysisChart.data.labels = sortedFactors.map(f => f[0]);
                factorAnalysisChart.data.datasets[0].data = sortedFactors.map(f => f[1]);
                factorAnalysisChart.update();
            }
        }

        // Render Trade History Table
        function renderTradeHistory() {
            tradeHistoryBody.innerHTML = '';
            if (!window.trades) {
                return;
            }
            window.trades.sort((a, b) => new Date(b.date) - new Date(a.date)); // Sort by date descending
            window.trades.forEach(trade => {
                let holdingPeriod = '';
                if (trade.date && trade.exitDate && trade.resultOutcome !== '진행 중') {
                    const entry = new Date(trade.date);
                    const exit = new Date(trade.exitDate);
                    const diffTime = Math.abs(exit - entry);
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    holdingPeriod = `${diffDays} 일`;
                } else if (trade.resultOutcome === '진행 중') {
                    holdingPeriod = '진행 중';
                }

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-800">${trade.date}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-800">${trade.exitDate || '-'}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-800">${holdingPeriod || '-'}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-800">${trade.stockName}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-800">${trade.tradeType}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-800">${trade.resultOutcome}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-800">${trade.rRatio !== null ? trade.rRatio : '-'}</td>
                    <td class="px-6 py-4 text-sm text-gray-800">${Array.isArray(trade.psychology) ? trade.psychology.join(', ') : ''}</td>
                    <td class="px-6 py-4 text-sm text-gray-800">${Array.isArray(trade.entryBasis) ? trade.entryBasis.join(', ') : ''}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <button onclick="editTrade('${trade.id}')" class="text-indigo-600 hover:text-indigo-900 ml-2">수정</button>
                        <button onclick="showConfirmModal('${trade.id}')" class="text-red-600 hover:text-red-900 ml-2">삭제</button>
                    </td>
                `;
                tradeHistoryBody.appendChild(row);
            });
        }

        // Function to populate form for editing
        window.editTrade = function(tradeId) {
            const tradeToEdit = window.trades.find(t => t.id === tradeId);
            if (!tradeToEdit) return;

            document.getElementById('date').value = tradeToEdit.date;
            document.getElementById('stockName').value = tradeToEdit.stockName;
            document.querySelector(`input[name="tradeType"][value="${tradeToEdit.tradeType}"]`).checked = true;
            document.getElementById('entryPrice').value = tradeToEdit.entryPrice;
            document.getElementById('stopLossPrice').value = tradeToEdit.stopLossPrice || '';
            document.getElementById('targetPrice').value = tradeToEdit.targetPrice || '';
            document.getElementById('half').value = tradeToEdit.half || '';
            document.getElementById('weight').value = tradeToEdit.weight;
            document.getElementById('exitDate').value = tradeToEdit.exitDate || '';

            document.querySelectorAll('input[name="psychology"]').forEach(cb => cb.checked = false);
            if (Array.isArray(tradeToEdit.psychology)) {
                tradeToEdit.psychology.forEach(tag => {
                    const checkbox = document.querySelector(`input[name="psychology"][value="${tag}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }

            document.querySelectorAll('input[name="entryBasis"]').forEach(cb => cb.checked = false);
            if (Array.isArray(tradeToEdit.entryBasis)) {
                tradeToEdit.entryBasis.forEach(tag => {
                    const checkbox = document.querySelector(`input[name="entryBasis"][value="${tag}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }

            resultOutcomeSelect.value = tradeToEdit.resultOutcome;
            rRatioInput.value = tradeToEdit.rRatio || '';
            exitReasonSelect.value = tradeToEdit.exitReason || '';

            document.querySelectorAll('input[name="factor"]').forEach(cb => cb.checked = false);
            if (Array.isArray(tradeToEdit.factors)) {
                tradeToEdit.factors.forEach(factor => {
                    const checkbox = document.querySelector(`input[name="factor"][value="${factor}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }

            replayQuestion1Select.value = tradeToEdit.replayQuestion1 || '';
            replayQuestion2Textarea.value = tradeToEdit.replayQuestion2 || '';
            replayQuestion3Input.value = tradeToEdit.replayQuestion3 || '';

            updateResultFieldRequirements();

            document.querySelector('#tradeForm button[type="submit"]').textContent = '매매 기록 업데이트';
            currentEditingTradeId = tradeId;

            document.getElementById('trade-entry').scrollIntoView({ behavior: 'smooth' });
        }

        // Function to show the confirmation modal
        window.showConfirmModal = function(tradeId) {
            tradeIdToDelete = tradeId;
            confirmModalOverlay.classList.remove('hidden');
        }

        // Function to hide the confirmation modal
        function hideConfirmModal() {
            confirmModalOverlay.classList.add('hidden');
            tradeIdToDelete = null;
        }

        // Handle actual delete logic
        confirmDeleteButton.addEventListener('click', async () => {
            if (!tradeIdToDelete) return;

            if (!window.db || !window.currentUserId || !window.userTradesCollectionRef) {
                document.getElementById('statusMessage').textContent = '데이터베이스가 아직 준비되지 않았습니다. 잠시 후 다시 시도해주세요.';
                document.getElementById('statusMessage').classList.remove('hidden');
                return;
            }

            document.getElementById('loadingSpinner').classList.remove('hidden');
            document.getElementById('statusMessage').classList.add('hidden');

            try {
                await window.deleteDoc(window.doc(window.userTradesCollectionRef, tradeIdToDelete));
                document.getElementById('statusMessage').textContent = '매매 기록이 성공적으로 삭제되었습니다!';
                document.getElementById('statusMessage').classList.remove('hidden');
                document.getElementById('statusMessage').classList.remove('text-red-600', 'bg-red-100', 'border-red-200');
                document.getElementById('statusMessage').classList.add('text-green-600', 'bg-green-100', 'border-green-200');
                hideConfirmModal();
                // 데이터는 onSnapshot을 통해 자동으로 업데이트되므로, 직접 렌더링/대시보드 업데이트 불필요
            } catch (error) {
                console.error("매매 기록 삭제 실패:", error);
                document.getElementById('statusMessage').textContent = '매매 기록 삭제 실패: ' + error.message;
                document.getElementById('statusMessage').classList.remove('hidden');
                document.getElementById('statusMessage').classList.remove('text-green-600', 'bg-green-100', 'border-red-200');
                document.getElementById('statusMessage').classList.add('text-red-600', 'bg-red-100', 'border-red-200');
            } finally {
                document.getElementById('loadingSpinner').classList.add('hidden');
            }
        });


        // Function to update required status of result fields
        function updateResultFieldRequirements() {
            const isCompleted = resultOutcomeSelect.value !== '진행 중';

            rRatioInput.required = isCompleted;
            exitReasonSelect.required = isCompleted;
            replayQuestion1Select.required = isCompleted;

            rRatioInput.placeholder = isCompleted ? "예: 1.5 (수익), 0.8 (손절)" : "진행 중인 매매는 선택 사항";
            exitReasonSelect.querySelector('option[value=""]').textContent = isCompleted ? "선택하세요" : "진행 중인 매매는 선택 사항";
            replayQuestion1Select.querySelector('option[value=""]').textContent = isCompleted ? "선택하세요" : "진행 중인 매매는 선택 사항";

            if (!isCompleted && currentEditingTradeId === null) {
                rRatioInput.value = '';
                exitReasonSelect.value = '';
                replayQuestion1Select.value = '';
                replayQuestion2Textarea.value = '';
                replayQuestion3Input.value = '';
                document.querySelectorAll('input[name="factor"]').forEach(cb => cb.checked = false); // 초기화 시 초기화
            }
        }

        // Event listener for resultOutcome change
        resultOutcomeSelect.addEventListener('change', updateResultFieldRequirements);

        // Handle Form Submission
        tradeForm.addEventListener('submit', async function(event) {
            event.preventDefault();

            if (!window.db || !window.currentUserId || !window.userTradesCollectionRef) {
                document.getElementById('statusMessage').textContent = '데이터베이스가 아직 준비되지 않았습니다. 잠시 후 다시 시도해주세요.';
                document.getElementById('statusMessage').classList.remove('hidden');
                return;
            }

            document.getElementById('loadingSpinner').classList.remove('hidden');
            document.getElementById('statusMessage').classList.add('hidden');

            const tradeData = {
                date: document.getElementById('date').value,
                stockName: document.getElementById('stockName').value,
                tradeType: document.querySelector('input[name="tradeType"]:checked').value,
                entryPrice: parseFloat(document.getElementById('entryPrice').value),
                stopLossPrice: parseFloat(document.getElementById('stopLossPrice').value) || null,
                targetPrice: parseFloat(document.getElementById('targetPrice').value) || null,
                half: parseFloat(document.getElementById('half').value) || null,
                weight: parseFloat(document.getElementById('weight').value),
                exitDate: document.getElementById('exitDate').value || null,
                psychology: Array.from(document.querySelectorAll('input[name="psychology"]:checked')).map(cb => cb.value),
                entryBasis: Array.from(document.querySelectorAll('input[name="entryBasis"]:checked')).map(cb => cb.value),
                resultOutcome: resultOutcomeSelect.value,
                rRatio: parseFloat(rRatioInput.value) || null,
                exitReason: exitReasonSelect.value || null,
                factors: Array.from(document.querySelectorAll('input[name="factor"]:checked')).map(cb => cb.value),
                replayQuestion1: replayQuestion1Select.value || null,
                replayQuestion2: replayQuestion2Textarea.value || null,
                replayQuestion3: parseInt(replayQuestion3Input.value) || null,
                timestamp: Date.now() // 최신순 정렬을 위한 타임스탬프
            };

            try {
                if (currentEditingTradeId) {
                    // 기존 매매 업데이트
                    await window.setDoc(window.doc(window.userTradesCollectionRef, currentEditingTradeId), tradeData);
                    document.getElementById('statusMessage').textContent = '매매 기록이 업데이트되었습니다!';
                    document.getElementById('statusMessage').classList.remove('hidden');
                } else {
                    // 새로운 매매 추가 (Firestore가 자동으로 ID 생성)
                    await window.setDoc(window.doc(window.userTradesCollectionRef, String(tradeData.timestamp)), tradeData); // 타임스탬프를 ID로 사용
                    document.getElementById('statusMessage').textContent = '새로운 매매 기록이 저장되었습니다!';
                    document.getElementById('statusMessage').classList.remove('hidden');
                }
                document.getElementById('statusMessage').classList.remove('text-red-600', 'bg-red-100', 'border-red-200');
                document.getElementById('statusMessage').classList.add('text-green-600', 'bg-green-100', 'border-green-200');

                tradeForm.reset(); // Clear form after submission
                document.getElementById('date').value = new Date().toISOString().split('T')[0]; // Reset date to today
                document.getElementById('exitDate').value = ''; // Clear exit date
                currentEditingTradeId = null; // Reset editing state
                document.querySelector('#tradeForm button[type="submit"]').textContent = '매매 기록 저장'; // Reset button text

                // 데이터는 onSnapshot을 통해 자동으로 업데이트되므로, 직접 렌더링/대시보드 업데이트 불필요
            } catch (error) {
                console.error("매매 기록 저장/업데이트 실패:", error);
                document.getElementById('statusMessage').textContent = '매매 기록 저장/업데이트 실패: ' + error.message;
                document.getElementById('statusMessage').classList.remove('hidden');
                document.getElementById('statusMessage').classList.remove('text-green-600', 'bg-green-100', 'border-red-200');
                document.getElementById('statusMessage').classList.add('text-red-600', 'bg-red-100', 'border-red-200');
            } finally {
                document.getElementById('loadingSpinner').classList.add('hidden');
            }
        });

        // Report related logic
        const reportPeriodRadios = document.querySelectorAll('input[name="reportPeriod"]');
        const reportDateSelector = document.getElementById('reportDateSelector');
        
        // Set default month for reportDateSelector to current month
        const today = new Date();
        const year = today.getFullYear();
        const month = (today.getMonth() + 1).toString().padStart(2, '0');
        reportDateSelector.value = `${year}-${month}`;

        reportPeriodRadios.forEach(radio => {
            radio.addEventListener('change', updateReports);
        });
        reportDateSelector.addEventListener('change', updateReports);

        function updateReports() {
            if (!window.trades || window.trades.length === 0) {
                document.getElementById('reportTotalTrades').textContent = '0';
                document.getElementById('reportWinRate').textContent = '0.00%';
                document.getElementById('reportAvgRR').textContent = '0.00';
                document.getElementById('reportTotalPNL').textContent = '0.00';
                return;
            }

            const selectedPeriodType = document.querySelector('input[name="reportPeriod"]:checked').value;
            const selectedDate = reportDateSelector.value; // YYYY-MM or YYYY

            let filteredTrades = [];

            if (selectedPeriodType === 'monthly') {
                const [year, month] = selectedDate.split('-');
                filteredTrades = window.trades.filter(trade => {
                    const tradeDate = new Date(trade.date);
                    return tradeDate.getFullYear() === parseInt(year) && (tradeDate.getMonth() + 1) === parseInt(month);
                });
            } else if (selectedPeriodType === 'quarterly') {
                const [yearStr, monthStr] = selectedDate.split('-'); // Still uses month selector for quarter
                const currentMonth = parseInt(monthStr);
                const quarter = Math.floor((currentMonth - 1) / 3) + 1; // 1-4
                
                filteredTrades = window.trades.filter(trade => {
                    const tradeDate = new Date(trade.date);
                    const tradeQuarter = Math.floor((tradeDate.getMonth()) / 3) + 1;
                    return tradeDate.getFullYear() === parseInt(yearStr) && tradeQuarter === quarter;
                });
            }

            const completedFilteredTrades = filteredTrades.filter(t => t.resultOutcome !== '진행 중');

            const totalTrades = completedFilteredTrades.length;
            const winTrades = completedFilteredTrades.filter(t => t.resultOutcome === '수익').length;
            const totalRR = completedFilteredTrades.reduce((sum, t) => sum + (parseFloat(t.rRatio) || 0), 0);
            const totalPNL = completedFilteredTrades.reduce((sum, t) => {
                const rRatio = parseFloat(t.rRatio) || 0;
                // Assuming R-Ratio directly translates to profit/loss percentage for simplicity in reports
                // For a more accurate P&L, you would need actual profit/loss values or initial capital + R-ratio logic
                return sum + (t.resultOutcome === '수익' ? rRatio : -rRatio);
            }, 0);


            document.getElementById('reportTotalTrades').textContent = totalTrades;
            document.getElementById('reportWinRate').textContent = `${totalTrades > 0 ? (winTrades / totalTrades * 100).toFixed(2) : 0.00}%`;
            document.getElementById('reportAvgRR').textContent = `${totalTrades > 0 ? (totalRR / totalTrades).toFixed(2) : 0.00}`;
            document.getElementById('reportTotalPNL').textContent = `${totalPNL.toFixed(2)}`;
        }

    </script>
</body>
</html>
